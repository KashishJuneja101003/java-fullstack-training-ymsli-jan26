What is RabbitMQ ?
_________________

RabbitMQ is a message broker that originally 
implements the Advance Message Queuing Protocol (AMQP)
AMQP standardizes messaging using Producers, Broker and Consumers.

AMQP standards was designed with the following main characteristics 
Security, Reliability, Interoperability

Reliability confirms the message was successfully delivered to the message 
broker and confirms that the message was successfully processed by the consumer


https://www.rfwireless-world.com/Terminology/AMQP-vs-JMS.html


RabbitMQ Instance with Docker
-------------------------------------
First, let’s pull the RabbitMQ docker image. 
We’ll use the 3-management version, so we get the Management plugin pre-installed.

docker pull rabbitmq:3-management

Now let’s stand it up. We’ll map port 15672 for the management 
web app and port 5672 for the message broker.

docker run --rm -it -p 15672:15672 -p 5672:5672 rabbitmq:3-management

Assuming that ran successfully, you’ve got an instance of RabbitMQ running! 
Bounce over to http://localhost:15672 to check out the management web app.

Log in using the default username (guest) and password (guest) and explore the management app a little bit.

 
starting rabbitMQ:
____________________
sudo service rabbitmq-server start
sudo service rabbitmq-server stop


http://localhost:15672 
with username and password guest





Spring boot rabbitmq order management example:
_______________________________________


server.port=9292

Configuration rabbitmq:
______________________

import org.springframework.amqp.core.*;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
import org.springframework.amqp.support.converter.MessageConverter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MessagingConfig {

    public static final String QUEUE = "javademo_queue";
    public static final String EXCHANGE = "javademo_exchange";
    public static final String ROUTING_KEY = "javademo_routingKey";

    @Bean
    public Queue queue() {
        return new Queue(QUEUE);
    }

    @Bean
    public TopicExchange exchange() {
        return new TopicExchange(EXCHANGE);
    }

    @Bean
    public Binding binding(Queue queue, TopicExchange exchange) {
        return BindingBuilder.bind(queue).to(exchange).with(ROUTING_KEY);
    }

    @Bean
    public MessageConverter converter() {
        return new Jackson2JsonMessageConverter();
    }

    @Bean
    public AmqpTemplate template(ConnectionFactory connectionFactory) {
        final RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
        rabbitTemplate.setMessageConverter(converter());
        return rabbitTemplate;
    }
}



rabbitmq order producer:
______________________

@Data
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class Order {

    private String orderId;
    private String name;
    private int qty;
    private double price;
}



@Data
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class OrderStatus {

    private Order order;
    private String status;//progress,completed
    private String message;
}



@RestController
@RequestMapping("/order")
public class OrderPublisher {

    @Autowired
    private RabbitTemplate template;

    @PostMapping("/{restaurantName}")
    public String bookOrder(@RequestBody Order order, @PathVariable String restaurantName) {
        order.setOrderId(UUID.randomUUID().toString());
        //restaurantservice
        //payment service
        OrderStatus orderStatus = new OrderStatus(order, "PROCESS", "order placed succesfully in " + restaurantName);
        template.convertAndSend(MessagingConfig.EXCHANGE, MessagingConfig.ROUTING_KEY, orderStatus);
        return "Success !!";
    }
}





rabbitmq order consumer:
______________________

@Component
public class OrderConsumer {

    @RabbitListener(queues = MessagingConfig.QUEUE)
    public void consumeMessageFromQueue(OrderStatus orderStatus) {
        System.out.println("Message recieved from queue : " + orderStatus);
    }
}



Retry and Error Handling
__________________________

If exception still exists after maximum retries then put message in a dead
 letter queue where it can be analyzed and corrected later.

What is a Dead Letter Queue?

In English vocabulary Dead letter mail is an undeliverable mail that 
cannot be delivered to the addressee.
 A dead-letter queue (DLQ), sometimes which is also known as an undelivered-message queue,
 is a holding queue for messages that cannot be delivered to their destinations due to some reason or other.

In message queueing the dead letter queue is a service implementation to
 store messages that meet one or more of the following failure criteria:

Message that is sent to a queue that does not exist.
Queue length limit exceeded.
Message length limit exceeded.
Message is rejected by another queue exchange.
Message reaches a threshold read counter number, because it is not consumed.
 Sometimes this is called a "back out queue".


Order management application : consumer should reject the order if order id is absent:


producer code:
____________


@Data
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class Order {

    private String orderId;
    private String name;
    private int qty;
    private double price;
}


@Data
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class OrderStatus {

    private Order order;
    private String status;//progress,completed
    private String message;
}




@Configuration
public class MessagingConfig {
	
	@Bean
	DirectExchange deadLetterExchange() {
		return new DirectExchange("deadLetterExchange");
	}
	
	@Bean
	DirectExchange exchange() {
		return new DirectExchange("javaexpExchange");
	}

	@Bean
	Queue dlq() {
		return QueueBuilder.durable("deadLetter.queue").build();
	}

	@Bean
	Queue queue() {
		return QueueBuilder.durable("javaexp.queue")
				.withArgument("x-dead-letter-exchange", "deadLetterExchange")
				.withArgument("x-dead-letter-routing-key", "deadLetter")
				.build();
	}

	@Bean
	Binding DLQbinding() {
		return BindingBuilder.bind(dlq()).to(deadLetterExchange()).with("deadLetter");
	}

	@Bean
	Binding binding() {
		return BindingBuilder.bind(queue()).to(exchange()).with("javaexp");
	}

	@Bean
	public MessageConverter jsonMessageConverter() {
		return new Jackson2JsonMessageConverter();
	}

	public AmqpTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
		final RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
		rabbitTemplate.setMessageConverter(jsonMessageConverter());
		return rabbitTemplate;
	}
}




@RestController
@RequestMapping("/order")
public class OrderPublisher {

    @Autowired
    private RabbitTemplate template;

    @PostMapping("/{restaurantName}")
    public String bookOrder(@RequestBody Order order, @PathVariable String restaurantName) {
        //order.setOrderId(UUID.randomUUID().toString());
        //restaurantservice
        //payment service
        OrderStatus orderStatus = new OrderStatus(order, "PROCESS", "order placed succesfully in " + restaurantName);
        template.convertAndSend("javaexpExchange","javaexp", orderStatus);
        return "Success !!";
    }
}




Consumer side:
_______________

@Configuration
public class MessagingConfig {
	
	@Bean
	DirectExchange deadLetterExchange() {
		return new DirectExchange("deadLetterExchange");
	}
	
	@Bean
	DirectExchange exchange() {
		return new DirectExchange("javaexpExchange");
	}

	@Bean
	Queue dlq() {
		return QueueBuilder.durable("deadLetter.queue").build();
	}

	@Bean
	Queue queue() {
		return QueueBuilder.durable("javaexp.queue")
				.withArgument("x-dead-letter-exchange", "deadLetterExchange")
				.withArgument("x-dead-letter-routing-key", "deadLetter")
				.build();
	}

	@Bean
	Binding DLQbinding() {
		return BindingBuilder.bind(dlq()).to(deadLetterExchange()).with("deadLetter");
	}

	@Bean
	Binding binding() {
		return BindingBuilder.bind(queue()).to(exchange()).with("javaexp");
	}

	@Bean
	public MessageConverter jsonMessageConverter() {
		return new Jackson2JsonMessageConverter();
	}

	public AmqpTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
		final RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
		rabbitTemplate.setMessageConverter(jsonMessageConverter());
		return rabbitTemplate;
	}
}





public class InvalidOrderException extends RuntimeException {
	private static final long serialVersionUID = -3154618962130084535L;

}


Now throw exception if order id is null:
______________________________________

@Component
public class OrderConsumer {

    @RabbitListener(queues ="javaexp.queue")
    public void consumeMessageFromQueue(OrderStatus orderStatus) {
    	if(orderStatus.getOrder().getOrderId()==null)
    		throw new InvalidOrderException();
        System.out.println("Message recieved from queue : " + orderStatus);
    }
}


application.properties
________________________

server.port=9293
spring.rabbitmq.listener.simple.retry.enabled= true
spring.rabbitmq.listener.simple.retry.initial-interval=3s
spring.rabbitmq.listener.simple.retry.max-attempts= 6
spring.rabbitmq.listener.simple.retry.max-interval=10s
spring.rabbitmq.listener.simple.retry.multiplier= 2



Here we enable the Spring Boot RabbitMQ retry mechanism and specify some more additional parameters-

initial interval
________________
	The message should be retried after an interval of 3s.

max-attempts
____________
	The message should be retried maximum of 6 times. After which it will be sent to dead letter Queue.

max-interval
___________
	The maximum time interval between two retries should never exceed 10s.

multiplier
___________
	The interval between second retry gets multiplied by 2.
	 But this interval can never exceed the max-interval. 
	So the retry interval values will be 3s, 6s, 10s, 10s, 10s. As 10 sec is the max interval specified.



Rabbit mq installation window 10:
________________________________

Install RabbitMQ in windows :

    Download and install ERlang http://erlang.org/download/otp_win64_22.3.exe
    Downlaod and install RabbitMQ https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server-3.8.8.exe
    Go to RabbitMQ Server install Directory C:\Program Files\RabbitMQ Server\rabbitmq_server-3.8.3\sbin
    Run command rabbitmq-plugins enable rabbitmq_management
    Open browser and enter http://localhost:15672/ to redirect to RabbitMQ Dashboard
    Also we can Open it with IP Address http://127.0.0.1:15672
    Login page default username and password is guest
    After successfully login you should see RabbitMQ Home page

    http://localhost:15672
