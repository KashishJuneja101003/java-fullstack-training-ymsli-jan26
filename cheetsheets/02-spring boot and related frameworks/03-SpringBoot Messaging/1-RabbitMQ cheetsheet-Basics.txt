What is RabbitMQ ?
_________________

RabbitMQ is a message broker that originally 
implements the Advance Message Queuing Protocol (AMQP)
AMQP standardizes messaging using Producers, Broker and Consumers.

AMQP standards was designed with the following main characteristics 
Security, Reliability, Interoperability

Reliability confirms the message was successfully delivered to the message 
broker and confirms that the message was successfully processed by the consumer


https://www.rfwireless-world.com/Terminology/AMQP-vs-JMS.html


RabbitMQ Instance with Docker
-------------------------------------
First, let‚Äôs pull the RabbitMQ docker image. 
We‚Äôll use the 3-management version, so we get the Management plugin pre-installed.

docker pull rabbitmq:3-management

Now let‚Äôs stand it up. We‚Äôll map port 15672 for the management 
web app and port 5672 for the message broker.

docker run --rm -it -p 15672:15672 -p 5672:5672 rabbitmq:3-management

Assuming that ran successfully, you‚Äôve got an instance of RabbitMQ running! 
Bounce over to http://localhost:15672 to check out the management web app.

Log in using the default username (guest) and password (guest) and explore the management app a little bit.

 
starting rabbitMQ:
____________________
sudo service rabbitmq-server start
sudo service rabbitmq-server stop


http://localhost:15672 
with username and password guest





Spring boot rabbitmq order management example:
_______________________________________


server.port=9292

Configuration rabbitmq:
______________________

import org.springframework.amqp.core.*;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
import org.springframework.amqp.support.converter.MessageConverter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MessagingConfig {

    public static final String QUEUE = "javademo_queue";
    public static final String EXCHANGE = "javademo_exchange";
    public static final String ROUTING_KEY = "javademo_routingKey";

    @Bean
    public Queue queue() {
        return new Queue(QUEUE);
    }

    @Bean
    public TopicExchange exchange() {
        return new TopicExchange(EXCHANGE);
    }

    @Bean
    public Binding binding(Queue queue, TopicExchange exchange) {
        return BindingBuilder.bind(queue).to(exchange).with(ROUTING_KEY);
    }

    @Bean
    public MessageConverter converter() {
        return new Jackson2JsonMessageConverter();
    }

    @Bean
    public AmqpTemplate template(ConnectionFactory connectionFactory) {
        final RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
        rabbitTemplate.setMessageConverter(converter());
        return rabbitTemplate;
    }
}



rabbitmq order producer:
______________________

@Data
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class Order {

    private String orderId;
    private String name;
    private int qty;
    private double price;
}



@Data
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class OrderStatus {

    private Order order;
    private String status;//progress,completed
    private String message;
}



@RestController
@RequestMapping("/order")
public class OrderPublisher {

    @Autowired
    private RabbitTemplate template;

    @PostMapping("/{restaurantName}")
    public String bookOrder(@RequestBody Order order, @PathVariable String restaurantName) {
        order.setOrderId(UUID.randomUUID().toString());
        //restaurantservice
        //payment service
        OrderStatus orderStatus = new OrderStatus(order, "PROCESS", "order placed succesfully in " + restaurantName);
        template.convertAndSend(MessagingConfig.EXCHANGE, MessagingConfig.ROUTING_KEY, orderStatus);
        return "Success !!";
    }
}





rabbitmq order consumer:
______________________

@Component
public class OrderConsumer {

    @RabbitListener(queues = MessagingConfig.QUEUE)
    public void consumeMessageFromQueue(OrderStatus orderStatus) {
        System.out.println("Message recieved from queue : " + orderStatus);
    }
}



Retry and Error Handling
__________________________

If exception still exists after maximum retries then put message in a dead
 letter queue where it can be analyzed and corrected later.

What is a Dead Letter Queue?

In English vocabulary Dead letter mail is an undeliverable mail that 
cannot be delivered to the addressee.
 A dead-letter queue (DLQ), sometimes which is also known as an undelivered-message queue,
 is a holding queue for messages that cannot be delivered to their destinations due to some reason or other.

In message queueing the dead letter queue is a service implementation to
 store messages that meet one or more of the following failure criteria:

Message that is sent to a queue that does not exist.
Queue length limit exceeded.
Message length limit exceeded.
Message is rejected by another queue exchange.
Message reaches a threshold read counter number, because it is not consumed.
 Sometimes this is called a "back out queue".


Order management application : consumer should reject the order if order id is absent:


producer code:
____________


@Data
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class Order {

    private String orderId;
    private String name;
    private int qty;
    private double price;
}


@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@ToString
public class OrderResponse {
    private Order order;
    private String status;
    private String message;
}



@Configuration
public class RabbitMQConfig {

	public static final String ORDER_QUEUE = "order.queue";
	public static final String ORDER_EXCHANGE = "order.exchange";
	public static final String ORDER_ROUTINGKEY = "order.routingkey";

	// DLQ constants
	public static final String DLQ_QUEUE = "order.dlq";
	public static final String DLQ_EXCHANGE = "order.dlq.exchange";
	public static final String DLQ_ROUTING_KEY = "order.dlq.routingkey";

	// 1Ô∏è‚É£ Main Queue (now DLQ-enabled, still backward compatible)
	@Bean
	public Queue orderQueue() {
		return QueueBuilder.durable(ORDER_QUEUE)
				.withArgument("x-dead-letter-exchange", DLQ_EXCHANGE)
				.withArgument("x-dead-letter-routing-key", DLQ_ROUTING_KEY).build();
	}

	// 2Ô∏è‚É£ Main Exchange
	@Bean
	public TopicExchange orderExchange() {
		return new TopicExchange(ORDER_EXCHANGE);
	}

	// 3Ô∏è‚É£ Main Binding
	@Bean
	public Binding orderBinding(Queue orderQueue, TopicExchange orderExchange) {
		return BindingBuilder.bind(orderQueue).to(orderExchange).with(ORDER_ROUTINGKEY);
	}

	// 4Ô∏è‚É£ Dead Letter Exchange
	@Bean
	public DirectExchange deadLetterExchange() {
		return new DirectExchange(DLQ_EXCHANGE);
	}

	// 5Ô∏è‚É£ Dead Letter Queue
	@Bean
	public Queue deadLetterQueue() {
		return QueueBuilder.durable(DLQ_QUEUE).build();
	}

	// 6Ô∏è‚É£ DLQ Binding
	@Bean
    public Binding deadLetterBinding() {
        return BindingBuilder
                .bind(deadLetterQueue())
                .to(deadLetterExchange())
                .with(DLQ_ROUTING_KEY);
    }
	// 7Ô∏è‚É£ Message Converter (shared)
    @Bean
    public MessageConverter converter() {
        return new Jackson2JsonMessageConverter();
    }

    // 8Ô∏è‚É£ RabbitTemplate (producer uses this, consumer ignores it)
    @Bean
    public AmqpTemplate amqpTemplate(
            ConnectionFactory connectionFactory,
            MessageConverter converter) {

        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
        rabbitTemplate.setMessageConverter(converter);
        return rabbitTemplate;
    }
}




@RestController
@RequestMapping("order")
public class OrderPublisher {

    @Autowired
    public RabbitTemplate rabbitTemplate;


    @PostMapping("{restName}")
    public String bookOrder(@RequestBody Order order){

       // order.setOrderId(UUID.randomUUID().toString());
        OrderResponse response=OrderResponse.builder()
                .order(order).message("order is booked").status("PENDING")
                .build();

        rabbitTemplate.convertAndSend(RabbitMQConfig.ORDER_EXCHANGE, 
        		RabbitMQConfig.ORDER_ROUTINGKEY, response);

        return "order is booked";
    }

}



Consumer side:
_______________

@Configuration
public class RabbitMQConfig {

	public static final String ORDER_QUEUE = "order.queue";
	public static final String ORDER_EXCHANGE = "order.exchange";
	public static final String ORDER_ROUTINGKEY = "order.routingkey";

	// DLQ constants
	public static final String DLQ_QUEUE = "order.dlq";
	public static final String DLQ_EXCHANGE = "order.dlq.exchange";
	public static final String DLQ_ROUTING_KEY = "order.dlq.routingkey";

	// 1Ô∏è‚É£ Main Queue (now DLQ-enabled, still backward compatible)
	@Bean
	public Queue orderQueue() {
		return QueueBuilder.durable(ORDER_QUEUE)
				.withArgument("x-dead-letter-exchange", DLQ_EXCHANGE)
				.withArgument("x-dead-letter-routing-key", DLQ_ROUTING_KEY).build();
	}

	// 2Ô∏è‚É£ Main Exchange
	@Bean
	public TopicExchange orderExchange() {
		return new TopicExchange(ORDER_EXCHANGE);
	}

	// 3Ô∏è‚É£ Main Binding
	@Bean
	public Binding orderBinding(Queue orderQueue, TopicExchange orderExchange) {
		return BindingBuilder.bind(orderQueue).to(orderExchange).with(ORDER_ROUTINGKEY);
	}

	// 4Ô∏è‚É£ Dead Letter Exchange
	@Bean
	public DirectExchange deadLetterExchange() {
		return new DirectExchange(DLQ_EXCHANGE);
	}

	// 5Ô∏è‚É£ Dead Letter Queue
	@Bean
	public Queue deadLetterQueue() {
		return QueueBuilder.durable(DLQ_QUEUE).build();
	}

	// 6Ô∏è‚É£ DLQ Binding
	@Bean
    public Binding deadLetterBinding() {
        return BindingBuilder
                .bind(deadLetterQueue())
                .to(deadLetterExchange())
                .with(DLQ_ROUTING_KEY);
    }
	// 7Ô∏è‚É£ Message Converter (shared)
    @Bean
    public MessageConverter converter() {
        return new Jackson2JsonMessageConverter();
    }

    // 8Ô∏è‚É£ RabbitTemplate (producer uses this, consumer ignores it)
    @Bean
    public AmqpTemplate amqpTemplate(
            ConnectionFactory connectionFactory,
            MessageConverter converter) {

        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
        rabbitTemplate.setMessageConverter(converter);
        return rabbitTemplate;
    }
}





public class InvalidOrderException extends RuntimeException {
	private static final long serialVersionUID = -3154618962130084535L;

}


Now throw exception if order id is null:
______________________________________

@Service
public class OrderConsumerService {

    @RabbitListener(queues = RabbitMQConfig.ORDER_QUEUE)
    public void consumeOrderResponse(OrderResponse orderResponse){
    	if (orderResponse.getOrder().getOrderId() == null) {
            throw new RuntimeException("Invalid order");
        }
        System.out.println("Processed: " + orderResponse);
    }
}



application.properties
________________________

server.port=9293
spring.rabbitmq.listener.simple.retry.enabled= true
spring.rabbitmq.listener.simple.retry.initial-interval=3s
spring.rabbitmq.listener.simple.retry.max-attempts= 6
spring.rabbitmq.listener.simple.retry.max-interval=10s
spring.rabbitmq.listener.simple.retry.multiplier= 2




server.port=9293                                  # Port on which the application (consumer service) will run

spring.rabbitmq.listener.simple.retry.enabled=true   # Enables retry mechanism for RabbitMQ consumers (@RabbitListener)

spring.rabbitmq.listener.simple.retry.initial-interval=3s   # Wait time of 3 seconds before the first retry

spring.rabbitmq.listener.simple.retry.max-attempts=6        # Total number of attempts to process a message (1 initial try + 5 retries)

spring.rabbitmq.listener.simple.retry.max-interval=10s      # Maximum wait time between retries will not exceed 10 seconds

spring.rabbitmq.listener.simple.retry.multiplier=2          # Multiplies the wait time by 2 for each retry (exponential backoff









Here we enable the Spring Boot RabbitMQ retry mechanism and specify some more additional parameters-

initial interval
________________
	The message should be retried after an interval of 3s.

max-attempts
____________
	The message should be retried maximum of 6 times. After which it will be sent to dead letter Queue.

max-interval
___________
	The maximum time interval between two retries should never exceed 10s.

multiplier
___________
	The interval between second retry gets multiplied by 2.
	 But this interval can never exceed the max-interval. 
	So the retry interval values will be 3s, 6s, 10s, 10s, 10s. As 10 sec is the max interval specified.





Better way to handle it:
______________________________________


package com.orderappclient.service;

import org.springframework.amqp.AmqpRejectAndDontRequeueException;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Service;

import com.orderappclient.config.RabbitMQConfig;
import com.orderappclient.model.OrderResponse;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
public class OrderConsumerService {

    @RabbitListener(queues = RabbitMQConfig.ORDER_QUEUE)
    public void consumeOrderResponse(OrderResponse orderResponse) {

        // 1Ô∏è‚É£ Basic null safety
        if (orderResponse == null || orderResponse.getOrder() == null) {
            log.warn("Received null order. Sending to DLQ");
            throw new AmqpRejectAndDontRequeueException("Null order");
        }

        // 2Ô∏è‚É£ Business validation
        if (orderResponse.getOrder().getOrderId() == null) {
            log.warn(
                "Invalid order received. orderId is null. Sending to DLQ. payload={}",
                orderResponse
            );

            // üî• IMPORTANT
            // Reject message so RabbitMQ sends it to DLQ
            throw new AmqpRejectAndDontRequeueException("Invalid orderId");
        }

        // 3Ô∏è‚É£ Normal processing
        log.info("Order processed successfully. orderId={}",
                 orderResponse.getOrder().getOrderId());

        System.out.println("Processed: " + orderResponse);
    }
}



# Spring AMQP ke noisy logs band karo
logging.level.org.springframework.amqp=ERROR
logging.level.org.springframework.retry=ERROR




Rabbit mq installation window 10:
________________________________

Install RabbitMQ in windows :

    Download and install ERlang http://erlang.org/download/otp_win64_22.3.exe
    Downlaod and install RabbitMQ https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server-3.8.8.exe
    Go to RabbitMQ Server install Directory C:\Program Files\RabbitMQ Server\rabbitmq_server-3.8.3\sbin
    Run command rabbitmq-plugins enable rabbitmq_management
    Open browser and enter http://localhost:15672/ to redirect to RabbitMQ Dashboard
    Also we can Open it with IP Address http://127.0.0.1:15672
    Login page default username and password is guest
    After successfully login you should see RabbitMQ Home page

    http://localhost:15672
